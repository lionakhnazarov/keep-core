{
  "language": "Solidity",
  "sources": {
    "contracts/BridgeStub.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/**\n * @title BridgeStub\n * @notice Minimal stub implementation of Bridge contract for local development\n */\ncontract BridgeStub {\n    address public bank;\n    address public relay;\n    address public ecdsaWalletRegistry;\n    address public reimbursementPool;\n\n    // Redemption request structure (matches real Bridge)\n    struct RedemptionRequest {\n        address redeemer;\n        uint64 requestedAmount;\n        uint64 treasuryFee;\n        uint64 txMaxFee;\n        uint32 requestedAt;\n    }\n\n    // Wallet structure for tracking state\n    struct Wallet {\n        bytes32 ecdsaWalletID;\n        bytes32 mainUtxoHash;\n        uint64 pendingRedemptionsValue;\n        uint32 createdAt;\n        uint32 movingFundsRequestedAt;\n        uint32 closingStartedAt;\n        uint32 state; // 0=Unknown, 1=Live, 2=MovingFunds, etc.\n    }\n\n    // Storage for pending redemptions: redemptionKey => RedemptionRequest\n    mapping(uint256 => RedemptionRequest) public pendingRedemptions;\n    \n    // Storage for wallets: walletPubKeyHash => Wallet\n    mapping(bytes20 => Wallet) public wallets;\n\n    // Events matching real Bridge\n    // Note: The Go ABI expects 6 parameters (without requestedAt), matching the real Bridge contract\n    event RedemptionRequested(\n        bytes20 indexed walletPubKeyHash,\n        bytes redeemerOutputScript,\n        address indexed redeemer,\n        uint64 requestedAmount,\n        uint64 treasuryFee,\n        uint64 txMaxFee\n    );\n\n    constructor(\n        address _bank,\n        address _relay,\n        address _ecdsaWalletRegistry,\n        address _reimbursementPool\n    ) {\n        bank = _bank;\n        relay = _relay;\n        ecdsaWalletRegistry = _ecdsaWalletRegistry;\n        reimbursementPool = _reimbursementPool;\n    }\n\n    function contractReferences()\n        external\n        view\n        returns (\n            address _bank,\n            address _relay,\n            address _ecdsaWalletRegistry,\n            address _reimbursementPool\n        )\n    {\n        return (bank, relay, ecdsaWalletRegistry, reimbursementPool);\n    }\n\n    function getRedemptionWatchtower()\n        external\n        pure\n        returns (address)\n    {\n        return address(0);\n    }\n\n    /// @notice For development: Allows calling requestNewWallet on WalletRegistry\n    function requestNewWallet() external {\n        IWalletRegistry(ecdsaWalletRegistry).requestNewWallet();\n    }\n    \n    /// @notice For development: Allows anyone to trigger requestNewWallet\n    function devRequestNewWallet() external {\n        (bool success, ) = ecdsaWalletRegistry.call(\n            abi.encodeWithSignature(\"requestNewWallet()\")\n        );\n        require(success, \"requestNewWallet call failed\");\n    }\n\n    /// @notice Callback function executed when a new wallet is created\n    /// @dev For now, this is a stub that does nothing. Wallets need to be\n    ///      manually registered using registerWallet() function.\n    ///      TODO: Implement automatic registration when crypto libraries are available\n    function __ecdsaWalletCreatedCallback(\n        bytes32 walletID,\n        bytes32 publicKeyX,\n        bytes32 publicKeyY\n    ) external {\n        // Stub implementation - wallets must be registered manually via registerWallet()\n        // This is because calculating walletPubKeyHash requires RIPEMD160 which is not\n        // available as a built-in Solidity function. The registerWallet() function\n        // should be called externally with the pre-calculated walletPubKeyHash.\n    }\n\n    /// @notice Callback function executed when wallet heartbeat fails\n    function __ecdsaWalletHeartbeatFailedCallback(\n        bytes32 walletID,\n        bytes32 publicKeyX,\n        bytes32 publicKeyY\n    ) external {\n        // Stub implementation - just accept the callback\n    }\n\n    // ============ Redemption Functions (for testing) ============\n\n    /// @notice Request a redemption (simplified for testing)\n    /// @param walletPubKeyHash 20-byte wallet public key hash\n    /// @param redeemerOutputScript Bitcoin script for redemption output\n    /// @param amount Amount in satoshis to redeem\n    function requestRedemption(\n        bytes20 walletPubKeyHash,\n        bytes calldata redeemerOutputScript,\n        uint64 amount\n    ) external {\n        require(wallets[walletPubKeyHash].state == 1, \"Wallet not live\");\n        require(amount > 0, \"Amount must be positive\");\n\n        uint64 treasuryFee = amount / 500; // 0.2% fee\n        uint64 txMaxFee = 20000; // Fixed max fee for testing\n        uint32 requestedAt = uint32(block.timestamp);\n\n        // Calculate redemption key (matches real Bridge)\n        // The real Bridge uses: keccak256(keccak256(CompactSizeUint-prefixed script) + walletPKH)\n        // CompactSizeUint encoding: for length <= 252, prefix is single byte\n        bytes memory prefixedScript;\n        if (redeemerOutputScript.length <= 252) {\n            prefixedScript = abi.encodePacked(uint8(redeemerOutputScript.length), redeemerOutputScript);\n        } else {\n            // For longer scripts, use 0xfd + 2 bytes little-endian (simplified - only handles <= 252 for now)\n            revert(\"Script too long for stub\");\n        }\n        bytes32 scriptHash = keccak256(prefixedScript);\n        uint256 redemptionKey = uint256(keccak256(abi.encodePacked(\n            scriptHash,\n            walletPubKeyHash\n        )));\n\n        // Store pending redemption\n        pendingRedemptions[redemptionKey] = RedemptionRequest({\n            redeemer: msg.sender,\n            requestedAmount: amount,\n            treasuryFee: treasuryFee,\n            txMaxFee: txMaxFee,\n            requestedAt: requestedAt\n        });\n\n        // Update wallet pending value\n        wallets[walletPubKeyHash].pendingRedemptionsValue += amount;\n\n        emit RedemptionRequested(\n            walletPubKeyHash,\n            redeemerOutputScript,\n            msg.sender,\n            amount,\n            treasuryFee,\n            txMaxFee\n        );\n    }\n\n    /// @notice Register a wallet (for testing - called after DKG)\n    /// @param walletPubKeyHash 20-byte wallet public key hash  \n    /// @param ecdsaWalletID 32-byte ECDSA wallet ID\n    function registerWallet(\n        bytes20 walletPubKeyHash,\n        bytes32 ecdsaWalletID\n    ) external {\n        wallets[walletPubKeyHash] = Wallet({\n            ecdsaWalletID: ecdsaWalletID,\n            mainUtxoHash: bytes32(0),\n            pendingRedemptionsValue: 0,\n            createdAt: uint32(block.timestamp),\n            movingFundsRequestedAt: 0,\n            closingStartedAt: 0,\n            state: 1 // Live\n        });\n    }\n\n    /// @notice Get wallet data\n    function getWallet(bytes20 walletPubKeyHash) \n        external \n        view \n        returns (Wallet memory) \n    {\n        return wallets[walletPubKeyHash];\n    }\n\n    /// @notice Get pending redemption request\n    function getPendingRedemption(uint256 redemptionKey)\n        external\n        view\n        returns (RedemptionRequest memory)\n    {\n        return pendingRedemptions[redemptionKey];\n    }\n\n    /// @notice Calculate redemption key (helper)\n    /// Matches Go code: keccak256(keccak256(CompactSizeUint-prefixed script) + walletPKH)\n    function calculateRedemptionKey(\n        bytes20 walletPubKeyHash,\n        bytes calldata redeemerOutputScript\n    ) external pure returns (uint256) {\n        // CompactSizeUint encoding: for length <= 252, prefix is single byte\n        bytes memory prefixedScript;\n        if (redeemerOutputScript.length <= 252) {\n            prefixedScript = abi.encodePacked(uint8(redeemerOutputScript.length), redeemerOutputScript);\n        } else {\n            revert(\"Script too long for stub\");\n        }\n        bytes32 scriptHash = keccak256(prefixedScript);\n        return uint256(keccak256(abi.encodePacked(\n            scriptHash,\n            walletPubKeyHash\n        )));\n    }\n\n    // ============ Redemption Parameters (for development) ============\n\n    /// @notice Get redemption parameters (matches real Bridge interface)\n    /// @dev Returns default values suitable for local development\n    function redemptionParameters()\n        external\n        pure\n        returns (\n            uint64 redemptionDustThreshold,\n            uint64 redemptionTreasuryFeeDivisor,\n            uint64 redemptionTxMaxFee,\n            uint64 redemptionTxMaxTotalFee,\n            uint32 redemptionTimeout,\n            uint96 redemptionTimeoutSlashingAmount,\n            uint32 redemptionTimeoutNotifierRewardMultiplier\n        )\n    {\n        // Default values for local development:\n        // - redemptionTimeout: 86400 seconds (24 hours) - matches test data\n        // - Other values set to reasonable defaults\n        return (\n            546,                    // redemptionDustThreshold (0.00000546 BTC)\n            500,                    // redemptionTreasuryFeeDivisor (0.2% fee)\n            20000,                  // redemptionTxMaxFee (satoshis)\n            200000,                 // redemptionTxMaxTotalFee (satoshis)\n            86400,                  // redemptionTimeout (24 hours in seconds)\n            0,                      // redemptionTimeoutSlashingAmount (no slashing in dev)\n            0                       // redemptionTimeoutNotifierRewardMultiplier (no reward in dev)\n        );\n    }\n\n    /// @notice Get redemption request minimum age (for development)\n    /// @dev Returns a default value suitable for local development\n    function redemptionRequestMinAge() external pure returns (uint32) {\n        return 3600; // 1 hour in seconds - matches test data\n    }\n}\n\ninterface IWalletRegistry {\n    function requestNewWallet() external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}